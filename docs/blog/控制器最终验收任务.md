# 23创意组ROS控制器最终验收任务
## 说明
* 本文是以markdown（一种轻量级标记语言）书写的，大家可以通过vscode等IDE参看本文的预览图（著名的csdn上的文章或者某些github上面的README.md就是运用这门简单的语言写的）
* 本任务是 __基于停车程序__ 而进一步加深的任务要求，完成本任务前请务必完成停车任务的书写
* 完成本任务后，我们会发布创意组各个组别的规则和未来的培养计划和方向，并公布各自组别的一个入组小测试，通过测试的同学未来的一年将跟着学长学习，并在大二大三继续该组别的比赛
## 前言
* 在前置的停车任务中，我们使用TEB作为我们的局部路径规划器。然而，相信各位在TEB调参发现，尽管TEB算法在局部路径规划算法有着很好的性能，但是其庞大的计算量、参数的灵敏性、实际导航的效果、以及其看似黑盒子的原理（对于没看过源码的同学来说），TEB作为我们的局部路径规划器，还是有一定的局限性和扩展性。
* 所以为了避免上述效果，本任务将实现我们自己书写的 __基于全局路径__ 的 __局部路径规划器__ 算法
## 任务要点
#### 1.路径追踪
* 全局路径，本质上是一组有无数里离散个点组成的路径信息。我们通过订阅全局路径规划期提供的 __全局路径__ 信息，选取合适的 __前向点(lfw:LookForwardPoints)__ ,作为小车当前位置下的 __目标点__ 并生成速度信息以实现小车对全局路径的追踪。
    * 请将move_base的全局路径规划器替换为global_planner
    * 全局路径的消息类型是nav_msgs/Path
    * 区别于teb算法或者其他的局部路径规划器，我们只需要让小车实现对全局路径的追踪即可， __不需要__ 生成局部路径信息
#### 2. 速度生成
* 通过获取小车当前位置和全局路径上合适的前向点直接的距离偏差(欧式直线距离)和航向(yaw)偏差，计算出小车当前位置需要的速度信息。
* 常见的路径追踪算法：
    * stanley
    * pure pursiut
    * 一些基础的算法：autolabor教程里乌龟追乌龟的案例
* 请务必注意关于小车当前的角速度的计算
#### 3.前向点的可视化
* 前向点的可视化有助于我们的参数调试和程序检验，通过RVIZ（RobotVisualization）对该前向点进行可视化
* 可视化可以视为一个发布订阅模型（发布者：你的程序，订阅者：rviz）,一下是结果参考的消息类型
    * visualization_msgs::Marker   （推荐尝试）
    * geometry_msgs::PoseStamped
#### 请记得不要忘记实现停车程序的功能~（本程序是基于停车程序写的）
## 考核完成判定
* 控制器源码书写
* 控制器跑车，完成地图一圈的跑车，暂不做时间要求。
## 附加题
#### 4.自适应卡尔曼滤波功能包的配置-robot-pose-ekf的使用
* 仿真中的odom轮式里程计往往在进行航迹演算的时候没有偏差，但在实际的应用场景，我们往往会使用robot_pose_ekf功能包对多个传感器（例如IMU：惯性测量单元，vo:vision odom视觉里程计，gps等）进行融合，合成一个较为稳定的odom话题
    * 要求使用robot_pose_ekf功能包对仿真小车进行配置，要求实现对IMU和轮式里程计进行融合
#### 5.使用PID算法实现对小车输出角速度的控制
* 比例、积分、微分控制,简称PID控制。
    * 入门：https://blog.csdn.net/skythinker616/article/details/123019829?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170662375416800188516915%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170662375416800188516915&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123019829-null-null.142^v99^pc_search_result_base2&utm_term=PID&spm=1018.2226.3001.4187
* 以下可选（完成以下任一即为完成该项任务）
    * 使用PID算法对小车的输出角速度进行控制
    * 使用PID算法对小车接近目标点进行减速控制
